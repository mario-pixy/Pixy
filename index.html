<!doctype html>
<html lang="it">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Pixy</title>
  <style>
    :root{
      --c: cyan;
      --glow: 0 0 55px var(--c);
      --glow-strong: 0 0 90px var(--c);
      --bg: #000;
    }

    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      overflow:hidden;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      font-family: -apple-system, system-ui, Arial, sans-serif;
    }

    /* Centro scena */
    .stage{
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding-bottom: env(safe-area-inset-bottom);
    }

    /* Faccia */
    #face{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:16px;
      transform: translateY(8px);
    }

    .eyes{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:46px;
    }

    .eye{
      width:110px;
      height:110px;
      background:var(--c);
      border-radius:28px;
      box-shadow: var(--glow);
      transition: all .18s ease;
      position:relative;
      overflow:hidden;
    }

    /* riflesso tipo ‚Äúvetro‚Äù */
    .eye::after{
      content:"";
      position:absolute;
      top:12px; left:14px;
      width:44px; height:18px;
      background:rgba(255,255,255,.22);
      border-radius:999px;
      transform: rotate(-8deg);
      filter: blur(.2px);
      opacity:.55;
    }

    /* bocca */
    .mouth{
      width:92px;
      height:26px;
      border-radius:999px;
      background: rgba(0,255,255,.95);
      box-shadow: 0 0 28px rgba(0,255,255,.55);
      transition: all .18s ease;
      position:relative;
      overflow:hidden;
    }

    /* bocca ‚Äúsorriso‚Äù */
    #face.happy .mouth{
      height:34px;
      width:110px;
      border-radius: 0 0 999px 999px;
      transform: translateY(-1px);
    }

    /* bocca triste */
    #face.sad .mouth{
      height:34px;
      width:110px;
      border-radius: 999px 999px 0 0;
      transform: translateY(4px);
      opacity:.85;
    }

    /* sorpresa */
    #face.surprised .mouth{
      width:34px;
      height:34px;
      border-radius: 50%;
      transform: translateY(-1px);
    }

    /* speaking: occhi ‚Äúrespirano‚Äù */
    #face.speaking .eye{
      height:132px;
      box-shadow: var(--glow-strong);
      transform: translateY(-1px);
    }

    /* listening: occhi ‚Äústretti‚Äù */
    #face.listening .eye{
      height:68px;
      box-shadow: var(--glow-strong);
      transform: scaleX(1.18);
    }

    /* thinking: micro wobble */
    #face.thinking{
      animation: wobble .7s ease-in-out infinite;
    }
    @keyframes wobble{
      0%,100%{ transform: translateY(8px) rotate(0deg); }
      50%{ transform: translateY(6px) rotate(.6deg); }
    }

    /* blink: chiude entrambi */
    #face.blink .eye{
      height:22px !important;
      border-radius: 999px;
      box-shadow: 0 0 40px rgba(0,255,255,.55);
    }

    /* wink: chiude solo uno */
    #face.wink-left .eye.left{
      height:22px !important;
      border-radius: 999px;
    }
    #face.wink-right .eye.right{
      height:22px !important;
      border-radius: 999px;
    }

    /* sleep/idle ‚Äúsoft‚Äù */
    #face.idle .eye{
      opacity:.92;
      box-shadow: 0 0 42px rgba(0,255,255,.42);
    }

    /* Overlay start */
    #overlay{
      position: fixed;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      background: radial-gradient(ellipse at center, rgba(0,255,255,.10), rgba(0,0,0,.92) 55%, rgba(0,0,0,1));
      color:#dff;
      text-align:center;
      padding: 24px;
    }
    #overlay .card{
      max-width: 520px;
      line-height:1.25;
      border: 1px solid rgba(0,255,255,.22);
      background: rgba(0,0,0,.35);
      padding: 18px 16px;
      border-radius: 16px;
      backdrop-filter: blur(6px);
      box-shadow: 0 0 35px rgba(0,255,255,.12);
    }
    #overlay .title{
      font-size: 18px;
      margin-bottom: 10px;
      font-weight: 700;
    }
    #overlay .sub{
      font-size: 14px;
      opacity:.9;
    }
    #overlay .hint{
      margin-top: 12px;
      font-size: 13px;
      opacity:.8;
    }

    /* Debug (spento di default) */
    #debug{
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: 18px;
      color: #fff;
      font: 14px -apple-system,system-ui;
      opacity: .9;
      display:none;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>

  <div id="overlay">
    <div class="card">
      <div class="title">Pixy √® pronto ü§ñ‚ú®</div>
      <div class="sub">Tocca una volta per abilitare microfono e voce.</div>
      <div class="hint">Poi: parla normalmente, Pixy ascolta ‚Üí risponde ‚Üí parla ‚Üí torna ad ascoltare da solo.</div>
    </div>
  </div>

  <div class="stage">
    <div id="face" class="idle">
      <div class="eyes">
        <div class="eye left"></div>
        <div class="eye right"></div>
      </div>
      <div class="mouth"></div>
    </div>
  </div>

  <div id="debug"></div>

<script>
/**
 * NOTE IMPORTANTI (iPhone):
 * - Per microfono e voce, iOS richiede SEMPRE un gesto dell‚Äôutente (tap) almeno una volta.
 * - Dopo il primo tap, possiamo continuare in automatico: ascolto ‚Üí risposta ‚Üí TTS ‚Üí ascolto.
 */

const SHOW_DEBUG = false;     // metti true se vuoi vedere testo/diagnostica
const AUTO_LISTEN = true;     // torna ad ascoltare da solo dopo che parla
const API_URL = "/api/chat";  // il tuo endpoint Vercel

const face = document.getElementById("face");
const overlay = document.getElementById("overlay");
const debugEl = document.getElementById("debug");
if (SHOW_DEBUG) debugEl.style.display = "block";

function dbg(...args){
  if(!SHOW_DEBUG) return;
  debugEl.textContent = args.map(a => (typeof a === "string" ? a : JSON.stringify(a, null, 2))).join("\n\n");
}

let started = false;
let busySpeaking = false;
let recognition = null;
let canSR = false;

// ====== STATE / ANIMAZIONI ======
let moodTimer = null;

function clearMoodSoon(ms=900){
  if(moodTimer) clearTimeout(moodTimer);
  moodTimer = setTimeout(() => {
    face.classList.remove("happy","sad","surprised");
  }, ms);
}

function setFaceState(state){
  face.classList.remove("idle","listening","speaking","thinking","blink","wink-left","wink-right");
  face.classList.add(state);
}

function blink(){
  face.classList.add("blink");
  setTimeout(() => face.classList.remove("blink"), 170);
}

function wink(side="left"){
  face.classList.add(side === "left" ? "wink-left" : "wink-right");
  setTimeout(() => face.classList.remove("wink-left","wink-right"), 220);
}

function applyMoodFromText(text){
  const t = (text || "").toLowerCase();

  // regole semplici ‚Äúsentiment‚Äù
  const happyWords = ["bene","ottimo","perfetto","grande","fantastico","ahaha","lol","evviva","bravo","top","che bello","figo"];
  const sadWords = ["mi dispiace","peccato","purtroppo","triste","mannaggia","accidenti","oh no"];
  const surpriseWords = ["wow","davvero","incredibile","no dai","serio","che cosa","oops"];

  const has = (arr) => arr.some(w => t.includes(w));

  if(has(sadWords)){
    face.classList.add("sad");
    clearMoodSoon(1200);
    return;
  }
  if(has(surpriseWords)){
    face.classList.add("surprised");
    clearMoodSoon(900);
    return;
  }
  if(has(happyWords)){
    face.classList.add("happy");
    clearMoodSoon(1200);
    return;
  }

  // micro ‚Äúvita‚Äù casuale
  const r = Math.random();
  if(r < 0.18) wink(Math.random() < 0.5 ? "left" : "right");
  if(r > 0.82) blink();
}

// ====== VOCE (TTS) MIGLIORE ======
let ttsUnlocked = false;
let chosenVoice = null;

function unlockTTSOnce(){
  if(ttsUnlocked) return;
  ttsUnlocked = true;

  try{
    // ‚Äúping‚Äù silenzioso per sbloccare speechSynthesis dopo il tap
    const u = new SpeechSynthesisUtterance(" ");
    u.volume = 0;
    window.speechSynthesis.speak(u);
    window.speechSynthesis.cancel();
  }catch(e){}
}

function pickBestItalianVoice(){
  const voices = window.speechSynthesis?.getVoices?.() || [];
  if(!voices.length) return null;

  // Priorit√†: voci ‚Äúmigliori‚Äù spesso su iOS/macOS
  const preferredNames = [
    "Eloquence", "Alice", "Federica", "Giorgio", "Paola",
    "Luca", "Silvia", "Francesca"
  ];

  // 1) prendi una voce italiana (it-IT o it_*)
  const itVoices = voices.filter(v => (v.lang || "").toLowerCase().startsWith("it"));
  if(!itVoices.length) return null;

  // 2) prova match per nome
  for(const name of preferredNames){
    const v = itVoices.find(x => (x.name || "").toLowerCase().includes(name.toLowerCase()));
    if(v) return v;
  }

  // 3) prova enhanced/localService se esiste
  const local = itVoices.find(v => v.localService);
  if(local) return local;

  // 4) fallback: prima italiana
  return itVoices[0];
}

function ensureVoiceReady(){
  // alcune piattaforme caricano le voci in ritardo
  chosenVoice = pickBestItalianVoice();
  if(chosenVoice) return;

  window.speechSynthesis.onvoiceschanged = () => {
    chosenVoice = pickBestItalianVoice();
  };
}

async function speak(text){
  return new Promise((resolve) => {
    const msg = (text || "").trim();
    if(!msg){
      resolve();
      return;
    }

    busySpeaking = true;
    setFaceState("speaking");
    applyMoodFromText(msg);

    try{
      const u = new SpeechSynthesisUtterance(msg);
      u.lang = "it-IT";

      // voce migliore se disponibile
      if(chosenVoice) u.voice = chosenVoice;

      // parametri pi√π ‚Äúumani‚Äù
      u.rate = 1.02;     // 1.0‚Äì1.08 spesso ok
      u.pitch = 1.12;    // un filo pi√π ‚Äúcarino‚Äù
      u.volume = 1;

      u.onend = () => {
        busySpeaking = false;
        setFaceState("idle");
        resolve();
      };
      u.onerror = () => {
        busySpeaking = false;
        setFaceState("idle");
        resolve();
      };

      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);

      // blink a met√† frase ogni tanto
      setTimeout(() => { if(busySpeaking && Math.random() < 0.55) blink(); }, 520);

    }catch(e){
      busySpeaking = false;
      setFaceState("idle");
      resolve();
    }
  });
}

// ====== CHIAMATA API ======
async function askPixy(text){
  const payload = { text };
  dbg("‚Üí USER:", text);

  try{
    setFaceState("thinking");

    const r = await fetch(API_URL, {
      method: "POST",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });

    const data = await r.json().catch(() => ({}));
    const reply = (data.text || "").trim();

    dbg("‚Üê PIXY:", reply || "(vuoto)");
    return reply || "Ok!";

  }catch(e){
    dbg("ERRORE API:", String(e));
    return "Ops, ho avuto un problema di connessione. Riproviamo?";
  }
}

// ====== SPEECH RECOGNITION ======
function setupRecognition(){
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  canSR = !!SR;

  if(!canSR) return;

  recognition = new SR();
  recognition.lang = "it-IT";
  recognition.interimResults = false;
  recognition.continuous = false; // su iOS √® pi√π stabile cos√¨

  recognition.onstart = () => {
    if(!busySpeaking) setFaceState("listening");
  };

  recognition.onerror = (e) => {
    dbg("ASR error:", e?.error || e);
    // rimaniamo idle, poi riproviamo al prossimo ciclo
    if(!busySpeaking) setFaceState("idle");
  };

  recognition.onend = () => {
    // Se non stiamo parlando e siamo in auto, riprova ad ascoltare
    if(AUTO_LISTEN && started && !busySpeaking){
      // piccolo delay per evitare loop aggressivi
      setTimeout(() => {
        if(started && !busySpeaking) safeStartListening();
      }, 350);
    }
  };

  recognition.onresult = async (event) => {
    const spoken = event?.results?.[0]?.[0]?.transcript || "";
    const userText = spoken.trim();
    if(!userText){
      // se vuoto, riparti
      if(AUTO_LISTEN && started) setTimeout(safeStartListening, 250);
      return;
    }

    // domanda ‚Üí risposta ‚Üí parla ‚Üí riparti
    const reply = await askPixy(userText);
    await speak(reply);

    if(AUTO_LISTEN && started){
      setTimeout(safeStartListening, 300);
    }
  };
}

function safeStartListening(){
  if(!canSR){
    // fallback: input testuale (se mai dovesse servire)
    const t = prompt("Scrivi a Pixy:");
    if(t && t.trim()){
      (async ()=>{
        const reply = await askPixy(t.trim());
        await speak(reply);
        if(AUTO_LISTEN && started) setTimeout(safeStartListening, 300);
      })();
    }
    return;
  }

  try{
    if(!busySpeaking){
      recognition.start();
    }
  }catch(e){
    // a volte start() lanciato troppo presto genera eccezione: riprova
    setTimeout(() => {
      try{
        if(!busySpeaking) recognition.start();
      }catch(_){}
    }, 450);
  }
}

// ====== START (1 tap) ======
function startOnce(){
  if(started) return;
  started = true;

  // rimuovi overlay
  overlay.style.display = "none";

  unlockTTSOnce();
  ensureVoiceReady();
  setupRecognition();

  // mini ‚Äúciao‚Äù iniziale (senza la frase fissa ‚Äúcome posso aiutarti oggi‚Äù ogni volta)
  (async ()=>{
    await speak("Ciao! Sono Pixy. Dimmi pure.");
    safeStartListening();
  })();
}

// tap/click: solo per avvio (poi tutto automatico)
document.addEventListener("pointerdown", startOnce, { passive:true });

// se vuoi che faccia ogni tanto blink da ‚Äúidle‚Äù
setInterval(() => {
  if(started && !busySpeaking && Math.random() < 0.22){
    blink();
  }
}, 2200);

// iniziale
ensureVoiceReady();
setFaceState("idle");
</script>

</body>
</html>
