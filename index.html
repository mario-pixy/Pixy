<!doctype html>
<html lang="it">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Pixy</title>
  <style>
    body{
      margin:0;
      background:#000;
      display:flex;
      justify-content:center;
      align-items:center;
      height:100vh;
      overflow:hidden;
      user-select:none;
      -webkit-user-select:none;
      -webkit-touch-callout:none;
    }

    #face{
      display:flex;
      flex-direction:row;
      align-items:center;
    }

    .eye{
      width:90px;
      height:90px;
      background:cyan;
      margin:25px;
      border-radius:20px;
      box-shadow:0 0 50px cyan;
      transition:all .2s ease;
    }

    /* Stati base */
    .speaking .eye{
      height:120px;
      box-shadow:0 0 90px cyan;
    }
    .listening .eye{
      height:60px;
      box-shadow:0 0 110px cyan;
      transform:scaleX(1.2);
    }

    /* micro “respiro” quando idle */
    @keyframes breathe {
      0% { transform:scale(1); }
      50% { transform:scale(1.03); }
      100% { transform:scale(1); }
    }
    .idle .eye{
      animation:breathe 2.2s ease-in-out infinite;
    }

    /* ---- EMOZIONI / LOoi vibes ---- */
    .happy .eye{
      border-radius:40px;
      transform:scale(1.08);
      box-shadow:0 0 120px cyan;
    }

    .surprised .eye{
      border-radius:10px;
      height:130px;
      box-shadow:0 0 150px #fff;
    }

    .thinking .eye{
      height:70px;
      transform:translateY(6px);
      box-shadow:0 0 70px cyan;
    }

    .love .eye{
      background:#ff4da6;
      box-shadow:0 0 140px #ff4da6;
    }

    .angry .eye{
      background:#ff3333;
      box-shadow:0 0 140px #ff0000;
    }

    .sleepy .eye{
      height:40px;
      opacity:0.65;
    }

    .excited .eye{
      transform:scale(1.12);
      box-shadow:0 0 170px cyan;
    }

    /* Debug box */
    #debug{
      position:fixed;
      left:12px; right:12px; bottom:18px;
      color:#fff;
      font:14px -apple-system,system-ui;
      opacity:.9;
      pointer-events:none;
    }
    #last{ margin-top:6px; white-space:pre-wrap; }
  </style>
</head>
<body>

  <div id="face">
    <div class="eye"></div>
    <div class="eye"></div>
  </div>

  <div id="debug">
    <div id="status">Stato: idle</div>
    <div id="last"></div>
  </div>

<script>
  // ====== CONFIG ======
  const DEBUG = false;         // true = mostra testo in basso
  const AUTO_LISTEN = true;    // dopo che parla torna ad ascoltare
  const AUTO_LISTEN_DELAY = 450;

  // ====== DOM ======
  const face = document.getElementById("face");
  const statusEl = document.getElementById("status");
  const lastEl = document.getElementById("last");
  const debugBox = document.getElementById("debug");
  if(!DEBUG) debugBox.style.display = "none";

  function setState(state){
    face.classList.remove("listening","speaking","idle");
    if(state==="listening") face.classList.add("listening");
    if(state==="speaking") face.classList.add("speaking");
    if(state==="idle") face.classList.add("idle");
    if(DEBUG) statusEl.textContent = "Stato: " + state;
  }

  // ====== Mood helpers ======
  function clearMoods(){
    face.classList.remove("happy","surprised","thinking","love","angry","sleepy","excited");
  }
  function setMood(mood){
    clearMoods();
    if(mood && mood !== "neutral") face.classList.add(mood);
  }
  function detectMood(text){
    const t = (text || "").toLowerCase();

    if (/(grande|ottimo|perfetto|bravo|top|bella|mitico|geniale|ci sta|spacca|bomba)/i.test(t)) return "happy";
    if (/(wow|incredibile|davvero\?|serio\?|nooo|what|pazzesco)/i.test(t)) return "surprised";
    if (/(amore|ti voglio bene|cuore|abbraccio|dolce|tesoro)/i.test(t)) return "love";
    if (/(errore|non va|non funziona|arrabbi|odio|che schifo)/i.test(t)) return "angry";
    if (/(stanco|sonno|dormire|zzz)/i.test(t)) return "sleepy";
    if (/(vediamo|penso|forse|analizziamo|un attimo|ragioniamo|calcoliamo)/i.test(t)) return "thinking";
    if (/(evvai|grandioso|yes|andiamo|spettacolo|forte)/i.test(t)) return "excited";

    return "neutral";
  }

  // ====== Reply cleaning (toglie finali inutili) ======
  function cleanReply(reply){
    if(!reply) return "";
    return reply
      .replace(/\s+$/g, "")
      .replace(/(come posso aiutarti oggi\??)\s*$/i, "")
      .replace(/(come posso aiutarti\??)\s*$/i, "")
      .trim();
  }

  // ====== iOS Audio unlock (serve un TAP) ======
  let audioUnlocked = false;
  function unlockAudio(){
    if(audioUnlocked) return;
    audioUnlocked = true;

    try{
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(" ");
      u.volume = 0;
      window.speechSynthesis.speak(u);
      window.speechSynthesis.cancel();
    }catch(e){}
  }

  // ====== TTS ======
  function speak(text){
    unlockAudio();

    const msg = (text || "").trim() || "Ok.";
    setState("speaking");

    // Applica mood durante il parlato
    setMood(detectMood(msg));

    setTimeout(() => {
      try{
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(msg);
        u.lang = "it-IT";
        u.rate = 1.0;
        u.pitch = 1.05;
        u.volume = 1;

        u.onend = () => {
          clearMoods();
          setState("idle");
          if(AUTO_LISTEN) setTimeout(() => startListening(true), AUTO_LISTEN_DELAY);
        };
        u.onerror = () => {
          clearMoods();
          setState("idle");
          if(AUTO_LISTEN) setTimeout(() => startListening(true), AUTO_LISTEN_DELAY);
        };

        window.speechSynthesis.speak(u);
      }catch(e){
        clearMoods();
        setState("idle");
        if(DEBUG) lastEl.textContent = "ERRORE TTS: " + e;
      }
    }, 50);
  }

  // ====== Call server (/api/chat) ======
  async function sendToPixy(text){
    try{
      if(DEBUG) lastEl.textContent = "Tu: " + text;

      // Effetto “thinking” mentre aspetta
      setState("speaking");
      setMood("thinking");

      const r = await fetch("/api/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text })
      });

      const ct = r.headers.get("content-type") || "";
      if(!ct.includes("application/json")){
        const raw = await r.text();
        clearMoods();
        setState("idle");
        if(DEBUG) lastEl.textContent = "ERRORE: risposta non JSON\n" + raw.slice(0, 250);
        return;
      }

      const data = await r.json();
      const replyRaw = (data.text || "").trim();
      const reply = cleanReply(replyRaw);

      if(DEBUG) lastEl.textContent = "Tu: " + text + "\nPixy: " + (reply || "(risposta vuota)");
      speak(reply || "Ok.");

    }catch(e){
      clearMoods();
      setState("idle");
      if(DEBUG) lastEl.textContent = "ERRORE: " + e;
    }
  }

  // ====== Speech Recognition ======
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  let recognition = null;
  let isListening = false;

  function startListening(fromAuto=false){
    // non ascoltare mentre parla
    if(face.classList.contains("speaking")) return;

    unlockAudio();

    // Su Safari iPhone spesso SR non esiste: fallback testo
    if(!SR){
      if(fromAuto) return; // non spam prompt in auto
      const t = prompt("Scrivi a Pixy:");
      if(t && t.trim()) sendToPixy(t.trim());
      return;
    }

    if(!recognition){
      recognition = new SR();
      recognition.lang = "it-IT";
      recognition.interimResults = false;
      recognition.continuous = false;

      recognition.onstart = () => {
        isListening = true;
        setState("listening");
      };

      recognition.onend = () => {
        isListening = false;
        if(!face.classList.contains("speaking")) setState("idle");
      };

      recognition.onerror = (e) => {
        isListening = false;
        setState("idle");
        if(DEBUG) lastEl.textContent = "ERRORE MIC/ASR: " + (e.error || "sconosciuto");

        // fallback testo solo se tap utente
        if(!fromAuto){
          const t = prompt("Non riesco a sentire. Scrivi a Pixy:");
          if(t && t.trim()) sendToPixy(t.trim());
        }
      };

      recognition.onresult = (event) => {
        const spoken = event.results?.[0]?.[0]?.transcript || "";
        const t = spoken.trim();
        if(t) sendToPixy(t);
        else if(!fromAuto){
          const x = prompt("Non ho capito. Scrivi a Pixy:");
          if(x && x.trim()) sendToPixy(x.trim());
        }
      };
    }

    if(isListening) return;

    try{
      recognition.start();
    }catch(e){
      isListening = false;
      setState("idle");
    }
  }

  // TAP = avvia ascolto (obbligatorio su iOS)
  document.body.addEventListener("click", () => startListening(false));

  // Stato iniziale
  setState("idle");
</script>

</body>
</html>
